import { sheets, sheetsAppend, sheetsRead } from "../sheets.ts";
import { CONFIG } from "../main.ts";
import { getPlayers } from "../standings.ts";
import { mutex } from "../mutex.ts";

// Final Fantasy stat definitions
export type FINStat = "HP" | "Magic" | "Evasion" | "Speed" | "Strength";

// Player FF state interface
export interface FINPlayerState {
  userId: string;
  playerName: string;
  stats: Record<FINStat, number>; // Level 0-4
  level2Choices: Partial<
    Record<
      FINStat,
      Partial<
        {
          colorSlotIndex: number;
          colorChoice: "W" | "U" | "B" | "R" | "G" | "C";
          upgradeIndex: number;
        }
      >
    >
  >;
  level3Choices: Partial<Record<FINStat, Partial<{ upgradeIndex: number }>>>;
  boosterSlots: BoosterSlot[];
}

// Booster slot definition
export interface BoosterSlot {
  rarity?: "rare/mythic" | "uncommon" | "common";
  color?: "W" | "U" | "B" | "R" | "G" | "C"; // C for colorless
  set?: string; // For stat-specific slots
  special?: FINStat; // For special Level 3 slots
}

// Stat-specific set associations
export const STAT_SETS: Record<FINStat, string> = {
  "HP": "BLB", // Bloomburrow for defense/healing
  "Magic": "TDM", // The Deckmaster for spells
  "Evasion": "DSK", // Duskmourn for evasion/surveil
  "Speed": "DFT", // Aetherdrift for speed/equipment
  "Strength": "FDN", // Foundation for strength/towns
};

// Map to track all player FF states
export const playerStates = new Map<string, FINPlayerState>();

// Global lock for protecting the user lock map and state restoration
const globalLock = mutex();
// Per-user locks for editing player states
const userLocks = new Map<string, ReturnType<typeof mutex>>();

/**
 * FIN Upgrades Sheet Documentation
 *
 * Sheet: "Upgrade Log" in the live spreadsheet
 * Range: A2:F (headers in row 1)
 *
 * Columns:
 * A - Player Name: The display name of the player who received the upgrade
 * B - Stat: The Final Fantasy stat that was upgraded (HP, Magic, Evasion, Speed, Strength)
 * C - Level: The new level of the stat after upgrade (1-4)
 * D - Customization: JSON string for Level 2/3 customizations (see format below)
 * E - Status: "complete" or "in-progress" - tracks whether upgrade is fully finished
 * F - Timestamp: When the upgrade was applied (auto-generated by sheets)
 *
 * Level 2 Customization Format (Column D):
 * JSON: {"colorSlotIndex": N, "colorChoice": "X", "upgradeIndex": M}
 * - colorSlotIndex: Index of which common slot to change color (0-based, any valid common slot)
 * - colorChoice: New color for the selected slot (W/U/B/R/G/C)
 * - upgradeIndex: Index of which common slot to upgrade to uncommon (0-based, any valid common slot)
 *
 * Level 3 Customization Format (Column D):
 * JSON: {"upgradeIndex": N}
 * - upgradeIndex: Index of which common slot to upgrade to uncommon (0-based, any valid common slot)
 *
 * Example rows:
 * PlayerName | Magic     | 1 | ""                                              | complete    | 2024-01-01
 * PlayerName | Magic     | 2 | {"colorSlotIndex":3,"colorChoice":"U","upgradeIndex":7} | complete    | 2024-01-02
 * PlayerName | Magic     | 3 | {"upgradeIndex":2}                              | complete    | 2024-01-03
 * PlayerName | Strength  | 2 | {"colorSlotIndex":1}                            | in-progress | 2024-01-04
 *
 * The sheet is read during bot startup to restore player states, and new rows
 * are appended when players complete upgrades through the Discord interface.
 */

// Initial booster slots for new players
function getInitialBoosterSlots(): BoosterSlot[] {
  return [
    { rarity: "rare/mythic", set: "FIN" },
    { rarity: "uncommon", set: "FIN" },
    { rarity: "uncommon", set: "FIN" },
    { rarity: "common", set: "FIN", color: "W" },
    { rarity: "common", set: "FIN", color: "U" },
    { rarity: "common", set: "FIN", color: "B" },
    { rarity: "common", set: "FIN", color: "R" },
    { rarity: "common", set: "FIN", color: "G" },
    { rarity: "common", set: "FIN", color: "C" },
  ];
}

export function applyStatUpgrade(
  state: FINPlayerState,
  stat: FINStat,
  level: number,
) {
  switch (level) {
    case 1:
      // Add two commons of the stat's set
      state.boosterSlots.push(
        { rarity: "common", set: STAT_SETS[stat] },
        { rarity: "common", set: STAT_SETS[stat] },
      );
      break;
    case 2:
      try {
        const config = state.level2Choices[stat];
        if (!config) {
          console.warn(`No Level 2 customization found for ${stat}`);
          return;
        }
        const { colorSlotIndex, colorChoice, upgradeIndex } = config;
        if (
          colorSlotIndex !== undefined && colorChoice !== undefined &&
          upgradeIndex !== undefined
        ) {
          // Validate indices are within bounds
          if (
            colorSlotIndex >= 0 && colorSlotIndex < state.boosterSlots.length &&
            upgradeIndex >= 0 && upgradeIndex < state.boosterSlots.length
          ) {
            // Apply color change to the selected slot
            state.boosterSlots[colorSlotIndex].color = colorChoice;

            // Apply rarity upgrade to the selected slot
            state.boosterSlots[upgradeIndex].rarity = "uncommon";
          }
        }
      } catch (error) {
        console.error(
          `Failed to parse Level 2 customization for ${stat}:`,
          error,
        );
      }
      break;
    case 3:
      // Parse customization and upgrade slot first, before adding the special slot
      {
        try {
          const config = state.level3Choices[stat];
          if (!config) {
            console.warn(`No Level 3 customization found for ${stat}`);
            return;
          }
          const { upgradeIndex } = config;
          if (upgradeIndex === undefined) {
            console.warn(
              `Incomplete Level 3 customization for ${stat}:`,
              config,
            );
            return;
          }

          // Validate index is within bounds and upgrade first
          if (upgradeIndex >= 0 && upgradeIndex < state.boosterSlots.length) {
            // Apply rarity upgrade to the selected slot
            state.boosterSlots[upgradeIndex].rarity = "uncommon";
          }
        } catch (error) {
          console.error(
            `Failed to parse Level 3 customization for ${stat}:`,
            error,
          );
        }
      }

      // Add special slot based on stat after upgrading existing slot
      state.boosterSlots.push({ special: stat });
      break;
    case 4:
      // Add rare/mythic slot of stat's set
      state.boosterSlots.push({ rarity: "rare/mythic", set: STAT_SETS[stat] });
      break;
  }
}

export async function restorePlayerStates() {
  using _ = await globalLock();

  // Read the Upgrade Log sheet to rebuild player states
  // Sheet format: [PlayerName, Stat, Level, Customization, Status, Timestamp]
  const upgradeRows = await readStateRows();

  const players = await getPlayers();
  playerStates.clear();

  // Initialize all players with base state (all stats at level 0)
  for (const player of players) {
    resetPlayer(player);
  }

  applyRecordedUpgrades(upgradeRows, players);
}

export async function restoreSinglePlayerState(playerId: string) {
  using _ = await globalLock();
  const players = await getPlayers();
  const player = players.find((p) => p.id === playerId);
  if (!player) {
    throw new Error(`Player with ID ${playerId} not found`);
  }
  resetPlayer(player);
  const upgradeRows = await readStateRows();
  upgradeRows.values = upgradeRows.values?.filter(
    (row) => row[0] === player.name,
  );
  applyRecordedUpgrades(upgradeRows, players);
  return playerStates.get(playerId);
}

function applyRecordedUpgrades(
  upgradeRows: { values?: string[][] },
  players: Awaited<ReturnType<typeof getPlayers>>,
) {
  // Apply upgrades from log in chronological order
  for (const row of upgradeRows.values ?? []) {
    const [playerName, stat, level, customization, status] = row;
    const player = players.find((p) => p.name === playerName);
    if (!player) continue;

    const state = playerStates.get(player.id);
    if (!state) continue;

    const ffStat = stat as FINStat;
    const statLevel = parseInt(level);

    if (statLevel > state.stats[ffStat]) {
      const parsedCustomization = customization && customization.trim() &&
        JSON.parse(customization);

      if (parsedCustomization) {
        switch (statLevel) {
          case 2:
            state.level2Choices[ffStat] = parsedCustomization;
            break;
          case 3:
            state.level3Choices[ffStat] = parsedCustomization;
            break;
          default:
            break;
        }
      }
      // Apply completed upgrades
      state.stats[ffStat] = statLevel;
      if (status === "complete") {
        applyStatUpgrade(state, ffStat, statLevel);
      }
    }
  }
}

async function readStateRows() {
  let upgradeRows;
  try {
    upgradeRows = await sheetsRead(
      sheets,
      CONFIG.LIVE_SHEET_ID,
      "Upgrade Log!A2:F",
    );
  } catch (error) {
    // If the sheet doesn't exist yet, just start with no upgrades
    console.log("Upgrade Log sheet not found, starting with empty upgrade log");
    upgradeRows = { values: [] };
  }
  return upgradeRows;
}

function resetPlayer(
  player: {
    rowNum: number;
    name: string;
    id: string;
    matchesPlayed: number;
    wins: number;
    losses: number;
    matchesToPlay: string;
    status: string;
    surveySent: boolean;
    row: any[];
  },
) {
  playerStates.set(player.id, {
    userId: player.id,
    playerName: player.name,
    stats: { HP: 0, Magic: 0, Evasion: 0, Speed: 0, Strength: 0 },
    level2Choices: {},
    level3Choices: {},
    boosterSlots: getInitialBoosterSlots(),
  });
}

/**
 * Finds the row number and status for a specific upgrade in the Upgrade Log sheet
 * @param playerName - The player's name
 * @param stat - The stat that was upgraded
 * @param level - The level of the upgrade
 * @returns Object with row number (1-based, -1 if not found) and status
 */
export async function findUpgradeRow(
  playerName: string,
  stat: FINStat,
  level: number,
): Promise<{ row: number; status?: string }> {
  try {
    const upgradeRows = await sheetsRead(
      sheets,
      CONFIG.LIVE_SHEET_ID,
      "Upgrade Log!A2:F",
    );

    // Find the row that matches this player, stat, and level
    for (let i = 0; i < (upgradeRows.values?.length || 0); i++) {
      const row = upgradeRows.values![i];
      const [rowPlayerName, rowStat, rowLevel, , status] = row;
      if (
        rowPlayerName === playerName &&
        rowStat === stat &&
        rowLevel === level.toString()
      ) {
        return {
          row: i + 2, // Convert 0-based index to 1-based row number (+1) plus header row (+1)
          status: status,
        };
      }
    }

    return { row: -1 }; // Not found
  } catch (error) {
    console.error("Error reading upgrade rows:", error);
    return { row: -1 };
  }
}

/**
 * Records a completed upgrade to the Upgrade Log sheet
 * @param playerName - The player's name
 * @param stat - The stat being upgraded
 * @param level - The new level
 * @param choices - The final choices data (optional for Level 1/4)
 * @returns Promise that resolves when logged
 */
export async function recordUpgrade(
  playerName: string,
  stat: FINStat,
  level: number,
  choices?: Record<string, unknown>,
): Promise<void> {
  const result = await findUpgradeRow(playerName, stat, level);

  // Check if an upgrade already exists for this stat/level
  if (result.row > 0) {
    throw new Error(
      `Upgrade already exists for ${playerName} ${stat} Level ${level}`,
    );
  }

  const timestamp = new Date().toISOString();
  await sheetsAppend(
    sheets,
    CONFIG.LIVE_SHEET_ID,
    "Upgrade Log!A:F",
    [[
      playerName,
      stat,
      level.toString(),
      choices ? JSON.stringify(choices) : "{}",
      "complete",
      timestamp,
    ]],
  );
}

/**
 * Counts the number of completed upgrades for a specific player
 * @param playerName - The player's name to count upgrades for
 * @returns Number of completed upgrades
 */
export async function countCompletedUpgrades(
  playerName: string,
): Promise<number> {
  try {
    const upgradeRows = await sheetsRead(
      sheets,
      CONFIG.LIVE_SHEET_ID,
      "Upgrade Log!A2:F",
    );

    let count = 0;
    for (const row of upgradeRows.values ?? []) {
      const [rowPlayerName, , , , status] = row;
      if (rowPlayerName === playerName && status === "complete") {
        count++;
      }
    }

    return count;
  } catch (error) {
    console.error("Error counting completed upgrades:", error);
    throw error;
  }
}

export async function getStateLock(userId: string) {
  using _ = await globalLock();
  let lock = userLocks.get(userId);
  if (!lock) {
    lock = mutex();
    userLocks.set(userId, lock);
  }
  return lock();
}
